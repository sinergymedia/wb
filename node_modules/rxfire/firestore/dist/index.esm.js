import { Observable } from 'rxjs';
import { map, filter, scan } from 'rxjs/operators';

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _fromRef(ref) {
    return new Observable(function (subscriber) {
        var unsubscribe = ref.onSnapshot(subscriber);
        return { unsubscribe: unsubscribe };
    });
}
function fromRef(ref) {
    return _fromRef(ref);
}
function fromDocRef(ref) {
    return fromRef(ref);
}
function fromCollectionRef(ref) {
    return fromRef(ref);
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function doc(ref) {
    return fromDocRef(ref);
}
/**
 * Returns a stream of a document, mapped to its data payload and optionally the document ID
 * @param query
 */
function docData(ref, idField) {
    return doc(ref).pipe(map(function (snap) { return snapToData(snap, idField); }));
}
function snapToData(snapshot, idField) {
    var _a;
    return __assign({}, snapshot.data(), (idField ? (_a = {}, _a[idField] = snapshot.id, _a) : null));
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ALL_EVENTS = [
    'added',
    'modified',
    'removed'
];
/**
 * Create an operator that determines if a the stream of document changes
 * are specified by the event filter. If the document change type is not
 * in specified events array, it will not be emitted.
 */
var filterEvents = function (events) {
    return filter(function (changes) {
        var hasChange = false;
        for (var i = 0; i < changes.length; i++) {
            var change = changes[i];
            if (events && events.indexOf(change.type) >= 0) {
                hasChange = true;
                break;
            }
        }
        return hasChange;
    });
};
/**
 * Create an operator that filters out empty changes. We provide the
 * ability to filter on events, which means all changes can be filtered out.
 * This creates an empty array and would be incorrect to emit.
 */
var filterEmpty = filter(function (changes) { return changes.length > 0; });
/**
 * Creates a new sorted array from a new change.
 * @param combined
 * @param change
 */
function processIndividualChange(combined, change) {
    switch (change.type) {
        case 'added':
            if (combined[change.newIndex] &&
                combined[change.newIndex].doc.id === change.doc.id) ;
            else {
                combined.splice(change.newIndex, 0, change);
            }
            break;
        case 'modified':
            if (combined[change.oldIndex] == null ||
                combined[change.oldIndex].doc.id === change.doc.id) {
                // When an item changes position we first remove it
                // and then add it's new position
                if (change.oldIndex !== change.newIndex) {
                    combined.splice(change.oldIndex, 1);
                    combined.splice(change.newIndex, 0, change);
                }
                else {
                    combined[change.newIndex] = change;
                }
            }
            break;
        case 'removed':
            if (combined[change.oldIndex] &&
                combined[change.oldIndex].doc.id === change.doc.id) {
                combined.splice(change.oldIndex, 1);
            }
            break;
        default: // ignore
    }
    return combined;
}
/**
 * Combines the total result set from the current set of changes from an incoming set
 * of changes.
 * @param current
 * @param changes
 * @param events
 */
function processDocumentChanges(current, changes, events) {
    if (events === void 0) { events = ALL_EVENTS; }
    changes.forEach(function (change) {
        // skip unwanted change types
        if (events.indexOf(change.type) > -1) {
            current = processIndividualChange(current, change);
        }
    });
    return current;
}
/**
 * Return a stream of document changes on a query. These results are not in sort order but in
 * order of occurence.
 * @param query
 */
function collectionChanges(query, events) {
    if (events === void 0) { events = ALL_EVENTS; }
    return fromCollectionRef(query).pipe(map(function (snapshot) { return snapshot.docChanges(); }), filterEvents(events), filterEmpty);
}
/**
 * Return a stream of document snapshots on a query. These results are in sort order.
 * @param query
 */
function collection(query) {
    return fromCollectionRef(query).pipe(map(function (changes) { return changes.docs; }));
}
/**
 * Return a stream of document changes on a query. These results are in sort order.
 * @param query
 */
function sortedChanges(query, events) {
    return collectionChanges(query, events).pipe(scan(function (current, changes) { return processDocumentChanges(current, changes, events); }, []));
}
/**
 * Create a stream of changes as they occur it time. This method is similar
 * to docChanges() but it collects each event in an array over time.
 */
function auditTrail(query, events) {
    return collectionChanges(query, events).pipe(scan(function (current, action) { return current.concat(action); }, []));
}
/**
 * Returns a stream of documents mapped to their data payload, and optionally the document ID
 * @param query
 */
function collectionData(query, idField) {
    return collection(query).pipe(map(function (arr) {
        return arr.map(function (snap) { return snapToData(snap, idField); });
    }));
}

export { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromCollectionRef, fromDocRef, fromRef, snapToData, sortedChanges };
//# sourceMappingURL=index.esm.js.map
